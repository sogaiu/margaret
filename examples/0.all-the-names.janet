#
# Primitive Patterns
#   Integer (..., -1, 0, 1, ...)
#   range                  =  (range r1 ?r2 ... ?rn)
#   set                    =  (set chars)
#   String ("...")
#   Boolean (true, false)
#
# Combining Patterns
#   any                    =  (any patt)
#   at-least               =  (at-least n patt)
#   at-most                =  (at-most n patt)
#   backmatch              =  (backmatch ?tag)
#   between (opt, ?)       =  (between min max patt)
#   choice (+)             =  (choice patt-1 patt-2 ...)
#   if                     =  (if cond patt)
#   if-not                 =  (if-not cond patt)
#   look (>)               =  (look offset ?patt)
#   not (!)                =  (not patt)
#   repeat (0, 1, 2, ...)  =  (repeat n patt)
#   sequence (*)           =  (sequence patt-1 patt-2 ...)
#   some                   =  (some patt)
#   split                  =  (split sep patt)
#   sub                    =  (sub window-patt patt)
#   thru                   =  (thru patt)
#   to                     =  (to patt)
#
# Captures
#   accumulate (%)         =  (accumulate pat ?tag)
#   argument               =  (argument n ?tag)
#   backref (->)           =  (backref prev-tag ?tag)
#   capture (<-, quote)    =  (capture patt ?tag)
#   cmt                    =  (cmt patt fun ?tag)
#   column                 =  (column ?tag)
#   constant               =  (constant k ?tag)
#   drop                   =  (drop patt)
#   error                  =  (error ?patt)
#   group                  =  (group patt ?tag)
#   int                    =  (int n ?tag)
#   int-be                 =  (int-be n ?tag)
#   lenprefix              =  (lenprefix n patt)
#   line                   =  (line ?tag)
#   number                 =  (number patt ?base ?tag)
#   position ($)           =  (position ?tag)
#   replace (/)            =  (replace patt subst ?tag)
#   uint                   =  (uint n ?tag)
#   uint-be                =  (uint-be n ?tag)
#   unref                  =  (unref rule ?tag)
#
# Built-ins
#   :a                     =  (range "AZ" "az")
#   :d                     =  (range "09")
#   :h                     =  (range "09" "AF" "af")
#   :s                     =  (set " \0\f\n\r\t\v")
#   :w                     =  (range "09" "AZ" "az")
#   :A                     =  (if-not :a 1)
#   :D                     =  (if-not :d 1)
#   :H                     =  (if-not :h 1)
#   :S                     =  (if-not :s 1)
#   :W                     =  (if-not :w 1)
#   :a+                    =  (some :a)
#   :d+                    =  (some :d)
#   :h+                    =  (some :h)
#   :s+                    =  (some :s)
#   :w+                    =  (some :w)
#   :A+                    =  (some :A)
#   :D+                    =  (some :D)
#   :H+                    =  (some :H)
#   :S+                    =  (some :S)
#   :W+                    =  (some :W)
#   :a*                    =  (any :a)
#   :d*                    =  (any :d)
#   :h*                    =  (any :h)
#   :s*                    =  (any :s)
#   :w*                    =  (any :w)
#   :A*                    =  (any :A)
#   :D*                    =  (any :D)
#   :H*                    =  (any :H)
#   :S*                    =  (any :S)
#   :W*                    =  (any :W)
#
# Aliases
#   (! patt)               =  (not patt)
#   ($ ?tag)               =  (position ?tag)
#   (% patt ?tag)          =  (accumulate patt ?tag)
#   (* patt-1 ... patt-n)  =  (sequence patt-1 ... patt-n)
#   (+ patt-1 ... patt-n)  =  (choice patt-1 ... patt-n)
#   (-> prev-tag ?tag)     =  (backref prev-tag ?tag)
#   (/ patt subst ?tag)    =  (replace patt subst ?tag)
#   (<- patt ?tag)         =  (capture patt ?tag)
#   (> offset ?patt)       =  (look offset ?patt)
#   (? patt)               =  (between 0 1 patt)
#   (1 patt)               =  (repeat 1 patt)
#   (2 patt)               =  (repeat 2 patt)
#   (3 patt)               =  (repeat 3 patt)
#   ...
#   (opt patt)             =  (between 0 1 patt)
#   (quote patt ?tag)      =  (capture patt ?tag)
#   'patt                  =  (capture patt)
#
